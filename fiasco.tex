\section{Application to Fiasco}

\subsection{Configuration of \& modifications to Fiasco}

\paragraph{Configuration}

\tobewritten{fill}

\todo[inline]{recently reconfigured without the use of regparm?}

\paragraph{\texttt{regparm} and \texttt{nonnull} attributes}

\tobewritten{fill}

\todo[inline]{revisit regparm attribute as per above configuration choice!}

\paragraph{GNU89 vs C99 inlining}

\tobewritten{fill}

\paragraph{Variable-length arrays}

\tobewritten{fill}

\paragraph{Inline Assembly}

LLVM's integrated assembler led to problems in several areas and was later
deactivated. The following section lists modifications that were initially
attempted to allow its use.

Fiasco uses the \emph{sub-sections} feature specific to the GNU
assembler~\cite{gas-subsections} in \url{/boot/ia32/boot\_idt.S}, which is
currently not supported by LLVM. The offending parts were changed to normal
section statements upon recommendation by \bjoern{mentions like this OK?}Adam
Lackorzyński, which unfortunately led to new errors upon booting.

The documentation on Clang's compatibility with current language standards and
popular compiler extensions~\cite[Inline assembly]{clang-compatibility}
explains why the integrated assembler does not accept ambiguous x86
instructions whose sizes can't be inferred from their operands; their handling
by the GNU assembler is considered a bug. Instructions with the appropriate
suffix were used where applicable.

There were \todo{elaborate}further problems concerning macro expansion in
\url{/kern/ia32/32/entry.S} and \url{/kern/ia32/32/entry-native.S}.

The use of the integrated assembler was then discontinued via the
\texttt{-no-integrated-as} option~\cite{manclang} in favour of the GNU
assembler with which the problematic parts of Fiasco are known to work.
All modifications made to this point were reverted.

\subsection{Fixing Clang's handling of \lstinline{__attribute__(init_priority)}}

With the aforementioned modifications in place, \todo{mention failure to load
debugging symbols in GDB?}Fiasco still failed to boot. Among other GCC
extensions to the \CPP language, Fiasco uses
\lstinline{__attribute__(init_priority(N))} in the \bjoern{is this a proper
term for it?}process of bootstrapping the kernel to ensure proper
initialization order of static objects across translation
units~\cite{gcc-initpriority}.

\bjoern{mention that this was actually discovered by Adam \& you?}It emerged
that this particular attribute is at the time of writing handled incorrectly by
Clang—both for constructors and destructors, although only the \todo{verify
with Adam!}former are of concern with regards to Fiasco—with the corresponding
bug report, filed December 2011, \todo{changes in the meantime!}still
pending~\cite{initpriority-bug}. I went to explore the usage of LLVM's
\emph{global\_ctors} array~\cite{langref-globalctors} proposed in the original
description of the bug. \emph{The following statements
\needspolish{shorten?}about the handling of constructors in Clang apply equally
to destructors, whose mention will be omitted for brevity.}

\tobewritten[inline]{explain LLVM global\_ctors?}

\paragraph{Constructor priorities in Clang}

Although Clang will parse prioritized constructors just fine and does in fact
keep them in memory conveniently as constructor/priority pairs, upon writing
the LLVM module this information is completely ignored. Clang creates a single
global initialization function (as mentioned in the bug report) into which
calls to the constructors are emitted in order of their priorities. This
function is then included in \emph{llvm.global\_ctors} using the default
priority of 65535, effectively confining priorities to the scope of
a translation unit.

\begin{framed}

Note that this behaviour is of limited use, as the \CPP standard already
mandates non-local variables inside a single translation unit to be initialized
in the order in which they were declared.
\emph{\_\_attribute\_\_(init\_priority(N))} as a GCC extension to \CPP was
specifically devised to solve the problem of ordering initializations across
translation units~\cite{gcc-initpriority}, which Clang fails to do.

\todo[inline]{cite the standard}
\bjoern[inline]{how to best put this?}

\end{framed}

My change was to add each constructor with its associated priority directly
when Clang is iterating over the previously gathered pairs, as suggested in the
bug report.

\tobewritten[inline]{explain my fix in Clang code}

\paragraph{Handling of \url{global\_ctors} in LLVM}

Despite Clang then emitting a useful listing of prioritized constructors into
each LLVM module, these priorities would still not translate into the expected
\texttt{.ctors}\todo{should probably describe these sections in
detail}-sections upon printing assembly for the given platform.  With
\bjoern{language like this OK?}nothing for the linker to pick up in the
resulting object file, constructors still ran in the order in which translation
units were handed to the linker.

I traced this back to flawed emission of constructors and destructors from the
\emph{global\_ctors} and \emph{global\_dtors} arrays during LLVM's code
generation phase, where information about priorities was again lost.

\tobewritten[inline]{explain LLVM's partly machine-independent code generation
pass in more detail to set the scene for section switching etc. below – maybe
in the initial treatment of LLVM architecture?}

\paragraph{\texttt{.ctors}-sections in LLVM 3.0}

While
\emph{Target\-Lowering\-Object\-File\-ELF}\footnote{\url{lib/CodeGen/TargetLoweringObjectFileImpl.cpp},
TargetLoweringObjectFileELF::getStaticCtorSection()}\footnote{\url{include/llvm/CodeGen/TargetLoweringObjectFileImpl.h}}
already provided means of emitting assembly for prioritized
\texttt{.ctors}-sections,
\emph{Asm\-Printer}\footnote{\url{lib/CodeGen/AsmPrinter/AsmPrinter.cpp},
\emph{AsmPrinter::EmitXXStructorList()}} only did the section switching once
using the default priority of 65535 before writing all of its constructors,
effectively discarding their associated priorities.

\todo[inline]{rework this whole paragraph after the TODO above}

\tobewritten[inline]{improper translation to binary using LLVM 3.0 – in detail?}

\paragraph{\texttt{.ctors}-sections in LLVM 3.1}

\tobewritten{working fix when using LLVM 3.1}I then discovered that the
offending code had already \todo{find LLVM commit that fixed this}received
a fix in \todo{mention that this came out after I set up my dev env?}LLVM
Release 3.1 (again in \emph{AsmPrinter}) to emit a new \texttt{.ctors}-section
with the correct priority for each \todo{also mention destructors}constructor
in \emph{llvm.global\_ctors}. Clang nevertheless still needed to have my
modifications applied.

\begin{leftbar}
  \bjoern[inline]{optionally write it like this?}
  Upon comparing results with Adam Lackorzyński it was then discovered that the
  offending code had already received a fix in LLVM Release 3.1 …
\end{leftbar}

\tobewritten[inline]{describe (yet to be done) changes regarding same
priorities in a translation unit as discovered 30-07-12?}
