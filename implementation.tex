Implementation of the passes described in the previous section was started as
an \needspolish{probably don't need to mention this}\emph{out-of-source} LLVM
project outside the LLVM repository. \texttt{opt} can include the generated
object files through the \texttt{-load=\textit{objectfile}} option and use the
passes they comprise.

\section{Analysis}

\texttt{-load=\textit{object-file}} option and use the passes they comprise.

\subsection{Preprocessing}


\section{Instrumentation}


\subsection{Control-flow between functions}


\subsection{Control-flow inside functions}

\tobewritten[inline]{fill}

\paragraph{Detect aliasing}
\tobewritten{fill}

\tobewritten[inline]{fill}

\section{Problems in using LLVM}

LLVM's primary purpose is to provide an optimizing compiler. As such it assumes
hardware to always work correctly. Especially the contents of registers and
normal memory locations may never unexpectedly changeâ€”which is precisely what
CFCSS anticipates and is looking to mitigate.

As a result, signature updates computing the bitwise XOR of an immediate
operand and a register whose contents are presumably known at most points in
time become candidates for \emph{constant folding}. Similarly, CFCSS checking
code appears to LLVM as a large collection of branches that will never be
taken, suggesting the use of \emph{dead code elimination}.

There is currently no way to mark certain instructions as off-limits to
subsequent optimization passes, likely because LLVM is not intended to be used
in this fashion. On the other hand, proper instrumentation should only add
instructions that are in fact required for CFCSS, which would eliminate the
need for further optimization, given cleanly written passes.

\tobewritten[inline]{currently evaluating whether "just not running additional
passes" will give the desired result reliably}

\tobewritten[inline]{mention LLVM Intrinsics, here or elsewhere}
